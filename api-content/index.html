{"posts":[{"title":"如果闪存中的电子是外部流入","content":"假设有两个1TB的内存卡，那么每张内存卡有：1×1000×1000×1000×1000×81\\times1000\\times1000\\times1000\\times1000\\times81×1000×1000×1000×1000×8bit也就是8×10128\\times10^{12}8×1012bit也就是说至少需要8×10128\\times10^{12}8×1012个电子。 已知1C=6.24×1018e1C=6.24\\times10^{18}e1C=6.24×1018e，那么这些电子的电荷量为8×1012e=8×10126.24×1018C=1.28×10−6C8\\times10^{12}e= \\displaystyle\\frac{8\\times10^{12}}{6.24\\times10^{18}}C=1.28\\times10^{-6}C8×1012e=6.24×10188×1012​C=1.28×10−6C。 那么两张内存卡互相受到的库仑力为： F=kq1q2r2=9×109(1.28×10−6)2r2N⋅m2=11.52×10−3r2N⋅m2≈102r2N⋅m2F=k \\displaystyle\\frac{q_{1}q_{2}}{r^{2}}\\\\\\quad=9\\times10^{9} \\displaystyle\\frac{(1.28\\times10^{-6})^{2}}{r^{2}}N\\cdot m^{2}\\\\\\quad= \\displaystyle\\frac{11.52\\times10^{-3}}{r^{2}}N\\cdot m^{2}\\\\\\quad\\approx \\displaystyle\\frac{10^{2}}{r^{2}}N\\cdot m^{2}F=kr2q1​q2​​=9×109r2(1.28×10−6)2​N⋅m2=r211.52×10−3​N⋅m2≈r2102​N⋅m2 假设两张内存卡距离为0.01m,则： F=10−20.012N=100NF= \\displaystyle\\frac{10^{-2}}{0.01^{2}}N=100NF=0.01210−2​N=100N 所以这是不可能的。 ","link":"https://An-nima.github.io/post/gong-shi-ce-shi/"},{"title":"Windows Server 2008 R2 部署 ASP.NET 6 ","content":"1.安装 Visual C++ Redistributable for Visual Studio 2015 https://www.microsoft.com/en-us/download/details.aspx?id=48145 2.安装补丁 KB2533623 https://support.microsoft.com/en-us/kb/2533623 3.安装 ASP.NET Core 6.0 Runtime - Windows Hosting Bundle https://dotnet.microsoft.com/en-us/download/dotnet/ 之后再新建网站和应用程序池。 4.在IIS 身份验证 中启动 匿名身份验证 等（可能不需要）连接方式改为特定用户连接 5.赋予IIS_USER文件夹权限 然后重启！ ","link":"https://An-nima.github.io/post/windows-server-2008-deploy-aspdotnet6/"},{"title":"C# Task vs Kotlin Coroutines vs Golang","content":" ","link":"https://An-nima.github.io/post/jVIMw58sp/"},{"title":"响应式编程，RxJS与Flink","content":" ","link":"https://An-nima.github.io/post/i5WyrTd2r/"},{"title":"C# 可空引用类型（Nullable reference types）","content":"可空值类型 C#2.0 c#默认的值类型是不可为null的，如int char等类型，类型后加上?号即代表是可空类型，即可赋值为null,如int? char?等。 ❌ int a = null; ✔️ int? a = null; 可空引用类型 C#8.0 在以往的版本中，引用类型默认都是可空的，如string a = null;，而在c#8.0后，可以选择性开启“可空引用类型（Nullable reference types）”。 不过从.net6开始，新项目将会默认开启可空类型。 只需设置 不同的vs版本需要设置不同的标签，如下 &lt;!--vs16.2+--&gt; &lt;Nullable&gt;enable&lt;/Nullable&gt; &lt;LangVersion&gt;8.0&lt;/LangVersion&gt; &lt;!--vs16 pre2 — vs16.1--&gt; &lt;NullableContextOptions&gt;enable&lt;/NullableContextOptions&gt; &lt;!--vs16 pre1--&gt; &lt;NullableReferenceTypes&gt;true&lt;/NullableReferenceTypes&gt; 启用后引用类型默认不可为null，即使用string a = null;时，intellisense和编译器都会给出警告（不过这个功能并不是默认开启的），需要写为string? a = null才可以，并且由于不可空，在初始化阶段必须赋予非空的值。 public class Person { public string Name { get; set; } } 此时会警告，因为属性Name不可为null，但是当创建对象时可能不会给对象赋值，那么此时Name就是string类型的默认值即null，而Name本身是Non-Nullable的。 public class Person { public string Name { get; set; } public Person(string? name) { Name = name; } } 这样也会警告，因为Name不可为null，但是name可能会为null。 public class Person { public string Name { get; set; } public Person(string name) { Name = name; } } 这样不会，但是如果你使用 var str = &quot;MyName&quot;; var person = new Person(s); 则会发生警告，因为str初始化（包括new）时候的引用类型编译器默认推断为可空引用类型。 同时编译是可以通过的，只是会出现警告，这本质上是加强了提示，如果想要强制避免可空类型出现异常的麻烦，则需要开启严格模式，只需配置标签 &lt;TreatWarningsAsErrors&gt;true&lt;/TreatWarningsAsErrors&gt; ","link":"https://An-nima.github.io/post/8znlnN4d-/"},{"title":"C# Grammar","content":"int.Parse(string s) 当把可能为空的string转换为int时，如果直接使用Parse可能会报错，所以需要try，而TryParse可以直接输出out，同时使用三目运算符，即可一句获得结果。 int? nullableValue = int.TryParse(&quot;nullable value&quot;, out var res) ? res : null; ValueTuple ","link":"https://An-nima.github.io/post/ofXNRo_Y_/"},{"title":"如何在10亿位π中快速寻找固定位数的数字","content":" pi-billion.txt ","link":"https://An-nima.github.io/post/vfEvFhIAg/"}]}